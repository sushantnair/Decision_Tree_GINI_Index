# -*- coding: utf-8 -*- 
"""EXPT4_DecisionTree_GINI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UyA6xinjAE2GEWoCYQOJ1IwmctCxcqYF
"""

import matplotlib.pyplot as plt
import pandas as pd
import math
import networkx as nx
from itertools import combinations

# Connecting to Google Drive
# from google.colab import drive
# drive.mount('/content/drive')

# Importing the dataset
# data = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/BuyCarNew.csv')
data = pd.read_csv('D:\BuyCarNew.csv')

treedata = dict()
nor = data.shape[0]       # Number of records
target_var_values = dict()
target_var = input('Enter the Traget Variable of the Dataset: ')
for value in data[f'{target_var}']:
    target_var_values[value] = target_var_values.get(value, 0) + 1
print(f'Target Variable Values: {target_var_values}')
infoD = 0
for val, cnt in target_var_values.items():
    infoD += (cnt / nor) * math.log((cnt / nor), 2)
infoD = -infoD
print(f'Information Gain at Target Variable {target_var}: {infoD:.3f}')

def find_root_node(data):
    colvals = dict()
    nor = data.shape[0]       # Number of records



    columns = data.columns[(data.columns != 'ID') & (data.columns != 'Buy_Car')].tolist()
    # colvals = dict()
    # OUTPUT: {'Age': {'Y': 5, 'M': 4, 'S': 5}, 'Income': {'H': 4, 'M': 6, 'L': 4}, 'Student': {'N': 7, 'Y': 7}, 'Credit_Rating': {'F': 8, 'E': 6}}
    # This dictionary's keys are the column names, and the values are dictionaries whose key is the unique value for each column
    # (like Y (youth), M (middleage), S (senior) are values for Age column) and value is the number of occurrences of that value in that column
    # e.g., youth occurs 5 times, middleage occurs 4 times and senior occurs 5 times in Age
    i = 0
    for column in columns:
        univals = dict()
        for value in data[column]:
            i += 1
            if i % nor == 0:
                i = 0
            univals[value] = univals.get(value, 0) + 1
        colvals[column] = univals



    infoattrD = dict()
    for column in columns:
        calc_cum = 0
        for val, count in colvals[column].items():
            # val_indices = [i for i, x in enumerate(data[column]) if x == val]
            val_indices = [i for i, x in data[column].items() if x == val]
            if not val_indices:
                continue
            cbc_values = [data['Buy_Car'][idx] for idx in val_indices]
            # reset count values for each value
            count_y = 0
            count_n = 0
            calc = 0
            for cbc_value in cbc_values:
                if cbc_value == "Y":
                    count_y += 1
                else:
                    count_n += 1
            try:
                calc = (count / nor) * (-((count_y / count) * math.log((count_y / count), 2)) - ((count_n / count) * math.log((count_n / count), 2)))
            except:
                print(f'')
                # this happens when one of the counts is zero, so log zero error is handled and value of calc is zero.
                # leaf node if all branches except out
                calc = 0
            calc_cum += calc
        infoattrD[f'{column}'] = calc_cum
        print(f'Information from Attributes: {infoattrD}')



    # Now calculate Gain in Information and find the root node for the given dataset
    gain = dict()
    for infoattr, info in infoattrD.items():
        gainval = infoD - info
        gain[infoattr] = gainval
    print(f'Gain in Information for Each Attribute: {gain}')



    if len(set(gain.values())) == 1:
        print(f'For {data.iloc[0, 0]}, all values are same. Hence it is a Leaf Node.')
        rootnode = None
        treedata[data.iloc[0, 0]] = {'Y': ''}
    else:
        rootnode = max(gain, key=gain.get)
        if type(data.iloc[0, 0]) == str:
            print(f'Thus it can be concluded that for the dataset \n{data}\nwhich has been derived from {data.iloc[0, 0]} value,\nthe root node is: {rootnode}')
            treedata[data.iloc[0, 0]] = {rootnode: ''}
        else:
            print(f'Thus it can be concluded that for the dataset \n{data}\nthe root node is: {rootnode}')
        colattrbs = {key: '' for key, val in colvals[rootnode].items()}
        treedata[rootnode] = colattrbs
    return (rootnode, colvals, treedata)

def find_derivative_dataframes(dataframe, node, colvals):
    # The goal is given a node, derive dataframes.
    # For example, the rootnode for the original dataframe "data" is Age.
    # Age has three values Youth Middleage and Senior
    # So, derive three dataframes.
    # First dataframe is based on Age Y, where the Age column is removed and the rows of data correspond to the rows in the original dataframe with Age Y
    # Second dataframe is based on Age M, where the Age column is removed and the rows of data correspond to the rows in the original dataframe with AgeM
    # Third dataframe is based on Age S, where the Age column is removed and the rows of data correspond to the rows in the original dataframe with Age S
    # data frame list
    dfl = list()
    for key, val in colvals[node].items():
        new_data_frame = dataframe[dataframe[f'{node}'] == key].copy()
        new_data_frame.drop(columns=['ID'], inplace=True)
        dfl.append(new_data_frame)
    print(f'The List of Dataframes Obtained from Node {node}: ')
    for df in dfl:
        print(df)
    return dfl

rootnode, colvals, treedata = find_root_node(data)
data_frame_dict1 = find_derivative_dataframes(data, rootnode, colvals)
print('Now, each dataframe derived from the root node will be processed to reveal branch nodes.')
for dataframe in data_frame_dict1:
    print(dataframe)
    try:
        branchnode = find_root_node(dataframe)
        print(branchnode)
    except:
        print()

# Plotting the Decision Tree

'''treedata = {
    "Age": {"Youth": '', "Middleage": '', "Senior": ''},
    "Youth": {"Student": ''},
    "Middleage": {"Y": ''},
    "Senior": {"Credit_Rating": ''},
    "Student": {"N": 'No', "Y": 'Yes'},
    "Credit_Rating": {"N": 'Excellent', "Y": 'Fair'}
}'''
print(f'Treedata: {treedata}')

G = nx.DiGraph()

for node, children in treedata.items():
    for child, link_value in children.items():
        G.add_edge(node, child, weight=link_value)

# Use 'dot' layout
pos = nx.drawing.nx_pydot.graphviz_layout(G, prog='dot')

nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=2020)

edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

plt.show()


"""# GINI Index Calculation for Root Node of Original Dataframe"""

def generate_combinations(node):
    values_of_node = [key for key, val in colvals[node].items()]
    #values_of_node = ['Baby', 'Youth', 'Middleage', 'Senior']
    print(values_of_node)

    # Generate all possible combinations of values of node
    all_combinations = []
    for r in range(1, len(values_of_node) + 1):
        all_combinations.extend(combinations(values_of_node, r))

    # Filter out incorrect combinations
    valid_combinations = [combo for combo in all_combinations if set(combo) == set(values_of_node)]

    # Restructure combinations to correct format
    final_combinations = []
    for combo in valid_combinations:
        internal_combinations = list(combinations(combo, len(combo) - 1))
        for internal_combo in internal_combinations:
            external_group = tuple(set(combo) - set(internal_combo))
            final_combinations.append((internal_combo, external_group))

    # Print generated combinations
    print(f'For the node {node} with values {values_of_node}, the generated combinations are as follows: ')
    for combo in final_combinations:
        print(combo)
    return final_combinations

# GINI Index Part...
# We shall calculate GINI Index for the rootnode
def calc_gini_for_combos(rootnode):
    print(f'{target_var_values}')
    giniD = 1
    for val, cnt in target_var_values.items():
        prob = cnt / nor
        giniD -= math.pow(prob, 2)
    print(f'GINI Index on Training Data: {giniD}')
    print(f'GINI Index on Rootnode ({rootnode}) will be found...')
    print(f'Values of Rootnode ({rootnode}): {colvals[rootnode]}')
    combos = generate_combinations(rootnode)
    print(f'Generating GINI index for {rootnode} based on the combinations generated ...')
    target_var_val_lst = [key for key, val in target_var_values.items()]
    gini_combo = dict()
    for combo in combos:
        gini = list()
        for items in combo:
            items_idcs_num = 0
            idcs_num = dict()
            val = 0
            for item in items:
                item_idcs = [i for i, x in data[f'{rootnode}'].items() if x == item]
                item_idcs_num = len(item_idcs)
                items_idcs_num += item_idcs_num
                for i in range(0, len(target_var_val_lst)):
                    idcs = [j for j, x in data[f'{target_var}'].items() if (x == target_var_val_lst[i] and (j in item_idcs))]
                    value = target_var_val_lst[i]
                    idcs_num[value] = idcs_num.get(value, 0) + len(idcs)
            for idx, num in idcs_num.items():
                val += math.pow((num / items_idcs_num), 2)
            val = 1 - val
            gini.append(val)
            ginicombovalue = (items_idcs_num / nor) * val
            gini_combo[f'{combo}'] = gini_combo.get(f'{combo}', 0) + ginicombovalue
    return gini_combo

gini_combo = calc_gini_for_combos(rootnode = 'Income')
correct_combo = min(gini_combo, key=gini_combo.get)
print(f'The lowest index is selected as correct partition: {correct_combo} = {gini_combo[correct_combo]:.3f}')
